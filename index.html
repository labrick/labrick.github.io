<!doctype html>
<html class="theme-next use-motion ">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="工作实验室">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="工作实验室">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="工作实验室">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

    <title> 工作实验室 </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CH">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">工作实验室</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/12/buddy-system-algorithm/" itemprop="url">
                伙伴系统算法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-10-12T17:22:51+08:00" content="2015-10-12">
            2015-10-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/颇有技术含量/" itemprop="url" rel="index"><span itemprop="name">颇有技术含量</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="背景">背景</h2><p>最近因为工作的需要开始调研伙伴系统算法，刚开始听到这个名词时竟然是一头雾水，什么都不知道，甚至对它还有一种神秘感、逃离感，不过这终抵不过理智的分析，搜索查一下总可以搞明白的。</p>
<h2 id="由分页引起的问题">由分页引起的问题</h2><p>我们知道内存分配时是按照“页框”进行分配的，一个页框也就4K，考虑多次分配释放之后的情况：</p>
<pre><code><span class="number">1.</span> 第一次申请<span class="number">2</span><span class="keyword">N</span>个页呢？简单，连续分<span class="number">2</span><span class="keyword">N</span>个页；
<span class="number">2.</span> 第二次再申请<span class="number">2</span><span class="keyword">N</span>个页？简单，接着上次的<span class="number">2</span><span class="keyword">N</span>个页往后分；
<span class="number">3.</span> 第三次请释放掉第一次申请的<span class="number">2</span><span class="keyword">N</span>个页？简单，直接收回；
<span class="number">4.</span> 第四次申请<span class="keyword">N</span>个页？是从第一次释放的位置分配还是从第二次申请空间的后面分配呢？
</code></pre><p>仔细想想：经过无数次无规律的内存申请释放之后，内存中肯定存在大量的小块内存，无法满足大内存申请的需求，即使小块内存是连着的也需要有种机制来将它们合并。伙伴系统就是解决大块内存管理问题的一种机制；</p>
<h2 id="伙伴的定义">伙伴的定义</h2><p>这里给出伙伴的概念，满足以下三个条件的称为伙伴：</p>
<pre><code><span class="bullet">1. </span>两个块大小相同；
<span class="bullet">2. </span>两个块地址连续；
<span class="bullet">3. </span>两个块必须是同一个大块中分离出来的；
</code></pre><h2 id="伙伴系统管理策略">伙伴系统管理策略</h2><p>可以在<a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="external">维基百科</a>上找到该算法的描述，大体如是：</p>
<h3 id="分配内存：">分配内存：</h3><ol>
<li>寻找大小合适的内存块（大于等于所需大小并且最接近2的幂，比如需要27，实际分配32）<ol>
<li>如果找到了，分配给应用程序。</li>
<li>如果没找到，分出合适的内存块。<ol>
<li>对半分离出高于所需大小的空闲内存块</li>
<li>如果分到最低限度，分配这个大小。</li>
<li>回溯到步骤1（寻找合适大小的块）</li>
<li>重复该步骤直到一个合适的块</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="释放内存：">释放内存：</h3><ol>
<li>释放该内存块<ol>
<li>寻找相邻的块，看其是否释放了。</li>
<li>如果相邻块也释放了，合并这两个块，重复上述步骤直到遇上未释放的相邻块，或者达到最高上限（即所有内存都释放了）。</li>
</ol>
</li>
</ol>
<p>上面这段文字可能看起来很费劲，我们看个内存分配和释放的示意图：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/buddy-system-algorithm/buddy-memory-allocation.jpg" alt="内存分配和释放示意图"></p>
<p>上图中，首先我们假设我们一个内存块有1024K，当我们需要给A分配70K内存的时候，</p>
<ol>
<li>我们发现1024K的一半大于70K，然后我们就把1024K的内存分成两半，一半512K。</li>
<li>然后我们发现512K的一半仍然大于70K，于是我们再把512K的内存再分成两半，一半是128K。</li>
<li>此时，我们发现128K的一半小于70K，于是我们就分配为A分配128K的内存。</li>
</ol>
<p>后面的，B，C，D都这样，而释放内存时，则会把相邻的块一步一步地合并起来（合并也必需按分裂的逆操作进行合并）。</p>
<p>这样的算法，用二叉树这个数据结构比较合适。</p>
<p>分配器的整体思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。如图所示，假设总大小为16单位的内存，我们就建立一个深度为5的满二叉树，根节点从数组下标[0]开始，监控大小16的块；它的左右孩子节点下标[1~2]，监控大小8的块；第三层节点下标[3~6]监控大小4的块……依此类推。</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/buddy-system-algorithm/binary-tree-of-buddy.jpg" alt="伙伴系统二叉树"></p>
<p>在分配阶段，首先要搜索大小适配的块，假设第一次分配3，转换成2的幂是4，我们先要对整个内存进行对半切割，从16切割到4需要两步，那么从下标[0]节点开始深度搜索到下标[3]的节点并将其标记为已分配。第二次再分配3那么就标记下标[4]的节点。第三次分配6，即大小为8，那么搜索下标[2]的节点，因为下标[1]所对应的块被下标[3~4]占用了。</p>
<p>在释放阶段，我们依次释放上述第一次和第二次分配的块，即先释放[3]再释放[4]，当释放下标[4]节点后，我们发现之前释放的[3]是相邻的，于是我们立马将这两个节点进行合并，这样一来下次分配大小8的时候，我们就可以搜索到下标[1]适配了。若进一步释放下标[2]，同[1]合并后整个内存就回归到初始状态。</p>
<p>一直到这，<a href="http://coolshell.cn/articles/10427.html" target="_blank" rel="external">这里</a>讲的都很好，但是接下来的内容，在原blog上就有所欠缺了，最起码我是没看懂他对程序的解释，下面我就将我对程序的解释贴在下面。</p>
<h2 id="伙伴系统程序分析">伙伴系统程序分析</h2><p><a href="https://github.com/cloudwu/buddy" target="_blank" rel="external">cloudwu</a>和<a href="https://github.com/wuwenbin/buddy2" target="_blank" rel="external">wuwenbin</a>写的两份开源实现和测试用例。实际上后一份是对前一份的精简和优化，而且这份实现真正体现了“极简”二字，追求突破常规的，极致简单的设计，<strong><a href="https://github.com/labrick/buddy2/blob/master/buddy2.c" target="_blank" rel="external">这里</a>是我对该程序的注解</strong>。</p>
<p>下面我将几个比较难以理解的点，也是传说中的精华部分在下面解释一下：</p>
<h3 id="伙伴分配器数据结构">伙伴分配器数据结构</h3><pre><code>truct buddy2{
    <span class="keyword">unsigned</span> size;            <span class="comment">// 管理内存的总单元数目，unsigned后省略的是int</span>
    <span class="keyword">unsigned</span> longest[<span class="number">1</span>];    <span class="comment">// 二叉树的节点标记，表明该节点可分配的最大单元数</span>
};
</code></pre><p>不论是从存储结构上还是从变量声明（数组成员数为1）上看，这个结构体都比较有意思，我们结合下面一段程序来看：</p>
<pre><code><span class="keyword">for</span> <span class="params">(i = <span class="number">0</span>; i &lt; <span class="number">2</span> * size - <span class="number">1</span>; ++i)</span>{
    <span class="keyword">if</span> <span class="params">(IS_POWER_OF_2<span class="params">(i+<span class="number">1</span>)</span>)</span>
        node_size /= <span class="number">2</span>;
    self-&gt;longest[i] = node_size;        <span class="comment">// 经验证，这里可以正确向后访问 </span>
}
</code></pre><p>它是不是发生了语法错误（i的值肯定会有大于0的时候），但是我在运行时竟然没有报错。然后我就做了个测试，程序在<a href="https://github.com/labrick/buddy2/blob/master/code_test.c" target="_blank" rel="external">这里</a>，为了解读方便，我再将程序片段拷贝一份：</p>
<pre><code>void main()
{
    <span class="keyword">struct</span> buddy2 <span class="keyword">self</span>;
      unsigned node_size;
      <span class="keyword">int</span> i,size=<span class="number">32</span>;

      <span class="keyword">self</span>-&gt;size = size;        <span class="comment">// 第一个结构体的size存放总的块数size</span>
      node_size = size * <span class="number">2</span>;        <span class="comment">// 总共的sizeof(unsigned)数</span>

    <span class="keyword">struct</span> buddy2* init = (<span class="keyword">struct</span> buddy2*)&amp;<span class="keyword">self</span>;

    init-&gt;size = <span class="number">32</span>
    init-&gt;longest[<span class="number">0</span>] = <span class="number">222</span>;
      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)
          printf(<span class="string">"self-&gt;size=%d\tself-&gt;longest[%d]=%d\r\n"</span>,<span class="keyword">self</span>-&gt;size,i,<span class="keyword">self</span>-&gt;longest[i]);
}
</code></pre><p>可以看到这样不符合C语言语法的程序当然会运行错误：segmentation fault，也就是产生了越界错误；</p>
<p>但是按照buddy2中的程序，我们再做一次实验：</p>
<pre><code><span class="keyword">void</span> main()
{
      <span class="keyword">struct</span> buddy2* <span class="keyword">self</span>;
      <span class="keyword">unsigned</span> node_size;
      <span class="keyword">int</span> i,size=<span class="number">32</span>;

      <span class="keyword">self</span> = (<span class="keyword">struct</span> buddy2*)ALLOC( <span class="number">2</span> * size * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));
      <span class="keyword">self</span>-&gt;size = size;        <span class="comment">// 第一个结构体的size存放总的块数size</span>
      node_size = size * <span class="number">2</span>;        <span class="comment">// 总共的sizeof(unsigned)数</span>

    <span class="comment">// 以下是验证longest访问正确性的</span>
    <span class="keyword">unsigned</span>* init = (<span class="keyword">unsigned</span>*)<span class="keyword">self</span>;
      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++,init++)
      {
          *init = i;
      }

      init = (<span class="keyword">unsigned</span>*)<span class="keyword">self</span>;
      printf(<span class="string">"memories allocated:\r\n"</span>);
      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">64</span>; i++,init++)
          printf(<span class="string">"%d\t"</span>,*init);
      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)
          printf(<span class="string">"self-&gt;size=%d\tself-&gt;longest[%d]=%d\r\n"</span>,<span class="keyword">self</span>-&gt;size,i,<span class="keyword">self</span>-&gt;longest[i]);
}
</code></pre><p>这里我是将所分配的内存区域按照0 1 2 3 …的方式存放数据，然后按照self-&gt;size,self-&gt;longest[1],self-&gt;longest[1] …的方式进行读取打印，查看显示的内容的存储方式问题，结果很出乎意料：</p>
<pre><code><span class="number">1</span>. 首先是能正常运行，没有发生数组越界问题，这个和上面一个程序的区别在于内存分配的方式不同；
<span class="number">2</span>. <span class="keyword">self</span>-&gt;longest[<span class="number">0</span>...]竟然是按照内存的存储方式连续读取的数值，很不可思议，不过这是事实；
<span class="number">3</span>. 只在分配的内存区域起始位置定义个结构体，<span class="keyword">self</span>-&gt;size出现一次，后面都是<span class="keyword">self</span>-&gt;longest的值；
</code></pre><p>以上结论出乎我的意料，但是事实证明它就是事实，只能接受，不过<strong>尚缺少理论支持</strong>。</p>
<p>现在我们在回到原程序当中，并且我对他做了一些改变再看一下结果：</p>
<pre><code><span class="keyword">void</span> main()
{
      <span class="keyword">struct</span> buddy2* <span class="keyword">self</span>;
      <span class="keyword">unsigned</span> node_size;
      <span class="keyword">int</span> i,size=<span class="number">32</span>;

      <span class="keyword">self</span> = (<span class="keyword">struct</span> buddy2*)ALLOC( <span class="number">2</span> * size * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));
      <span class="keyword">self</span>-&gt;size = size;        <span class="comment">// 第一个结构体的size存放总的块数size</span>
      node_size = size * <span class="number">2</span>;        <span class="comment">// 总共的sizeof(unsigned)数</span>

      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span> * size - <span class="number">1</span>; ++i) {
        <span class="keyword">if</span> (IS_POWER_OF_2(i+<span class="number">1</span>))
          node_size /= <span class="number">2</span>;
        <span class="keyword">self</span>-&gt;longest[i] = node_size;        <span class="comment">// 经验证，这里可以正确向后访问 </span>
      }

      printf(<span class="string">"memories allocated:\r\n"</span>);
    <span class="keyword">unsigned</span>* init = (<span class="keyword">unsigned</span>*)<span class="keyword">self</span>;
      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">2</span> * size; i++,init++)
      {
          printf(<span class="string">"%d\n"</span>,*init);
      }
}
</code></pre><p>我们打印出的结果是：两个32，2个16，4个8，8个4，16个2，32个1</p>
<p>第一个32是self-&gt;size，第二个是根节点0，后面依次为节点1,2,3…</p>
<p>这样的存储确实很牛逼，占用空间少，操作简单，不过难以理解；</p>
<h3 id="调整参数为2的幂次方">调整参数为2的幂次方</h3><pre><code><span class="keyword">static</span> unsigned fixsize(unsigned <span class="keyword">size</span>){
    <span class="keyword">size</span> |= <span class="keyword">size</span> &gt;&gt; <span class="number">1</span>;
    <span class="keyword">size</span> |= <span class="keyword">size</span> &gt;&gt; <span class="number">2</span>;
    <span class="keyword">size</span> |= <span class="keyword">size</span> &gt;&gt; <span class="number">4</span>;
    <span class="keyword">size</span> |= <span class="keyword">size</span> &gt;&gt; <span class="number">8</span>;
    <span class="keyword">size</span> |= <span class="keyword">size</span> &gt;&gt; <span class="number">16</span>;
    <span class="keyword">return</span> <span class="keyword">size</span>+<span class="number">1</span>;
}
</code></pre><p>找到个注释是这样的：</p>
<pre><code>/*
 * 把<span class="built_in">size</span>调整到向上取到最近的<span class="number">2</span>次幂
 * <span class="built_in">size</span> |= <span class="built_in">size</span> &gt;&gt; n;表示从低位到高位按n位分组,每组内高n位复制到低n位
 * 最后经过处理<span class="built_in">size</span>是从最高位的<span class="number">1</span>开始往低位全<span class="number">1</span>的整数
 * <span class="keyword">return</span> <span class="built_in">size</span> + <span class="number">1</span>; 得到向上凑够最近<span class="number">2</span>次幂
 */
</code></pre><p>说实话，我没看懂。</p>
<h3 id="结束">结束</h3><p>搞懂上面的两个问题，尤其是第一个问题，后面的阅读都很顺利了。</p>
<h2 id="伙伴系统优缺点">伙伴系统优缺点</h2><p>伙伴分配的实质就是一种特殊的“分离适配”，即将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。</p>
<p>其优点是快速搜索合并（O(logN)时间复杂度）以及低外部碎片（最佳适配best-fit）；</p>
<p>其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。 </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/10/05/echo-after-think-over/" itemprop="url">
                念念不忘 必有回响
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-10-05T12:45:48+08:00" content="2015-10-05">
            2015-10-05
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/让生活更上一层楼/" itemprop="url" rel="index"><span itemprop="name">让生活更上一层楼</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="那时候">那时候</h2><p>从开始学语文到现在，就没有写好过作文，怕考语文就是怕考作文，通篇瞎扯，无逻辑、无辞藻。下面是一个好友的随笔，我借来学习学习。:-) :-) :-)</p>
<h2 id="正文">正文</h2><p>阴雨连绵的夏末秋初，草木却依旧葱茏着，被雨水洗刷后愈加清新明亮。出了车站就已转向，分不清东南西北。这座小城转瞬之间，已不再是我初次到访时的模样。新的草木和建筑，从旧土壤里萌发生长，一如被战争摧毁的罗马在废墟上重建，此刻它焕然一新。</p>
<p>那时候，我大概……二十岁？记不清了。而在我离开后的这几年，我其实，过得也还好。我在鳞次栉比的水泥森林间行走，在夜晚会热闹起来的大街上，遇见很多的人。我看见他们张望、交谈、笑，看见他们各自生活的一角，看见一扇扇窗口里漏出的暖黄的灯火。跟二十岁相比，虽然过着不咸不淡的生活，但我知道自己仍在悄悄变化着。譬如一颗心，何尝还是二十岁的心？谁能保持赤子的情怀，只因没有看过这个世界，就毫无畏惧地沿着一条路跑下去，无怨无悔。那样倔强，倔强到根本不信有自己的意志打动不了的世界。</p>
<p>可是过了这几年，我开始想会不会因为那时不过是小孩儿？当现在我有能力对着乱七八糟的旅游纪念品买上一气、到处胡吃海塞走累了就打车、忘带了毛巾水杯到超市买自己喜欢的而不用考虑价格时，我会记起当年那场狼狈中断的旅行。站在同样的地方，仿佛看见二十岁时的自己从千年古渡口逆光走来，带着某种陌生的熟悉，似是昨日相识的新友。她问我是否后悔，而我无法回答，唯有默然。</p>
<p>你知道我在害怕么？我害怕忘了当初的自己，因为一旦忘了，我就要失去那部分我自己了——懵懂却执着，傻到浑身都是勇气。</p>
<p>最是人间留不住，朱颜辞镜花辞树。</p>
<p>踏着濡湿的青石阶慢慢地走，雾水漫漫，沾潮了衣衫。僧人们正在朝会。经幡随风涌动，木鱼点点地敲，朦胧氤氲的香火里，平缓而急促的诵经声伴着秋雨濛濛，竟有些令人安宁的静谧与庄重。有香客在堂前的莲花座上长跪拜谒，虔诚之下，想来也是隐藏着有求于佛的愿请。记得准备启程时，朋友让我去这名寺里求一支签，说如果签好就带回来，如果不好就扔掉。可我拒绝，因为不肯把自己的命运交给别人，哪怕是大慈大悲的佛祖也不行。我总想把选择权握在自己手里，只有这样，才不会后悔。因为人，总是舍不得怪罪自己，所以难得后悔。</p>
<p>《金刚经》里说：一切有为法，如梦幻泡影，如露亦如电，应作如是观。我对自己的执着，终是有所回应。那些落寞的行程，随着自己的重塑和叙述，变成了别人眼中的故事。而我不会较真，只将这个故事随随便便地放在这里，点上台灯，就着一壶热茶喝下，不再像个被执念困住的木偶，从此全然如新。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/12/assembly-in-c/" itemprop="url">
                C语言中嵌入汇编程序
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-12T11:39:07+08:00" content="2015-09-12">
            2015-09-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/linux0-11相关/" itemprop="url" rel="index"><span itemprop="name">linux0.11相关</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="背景">背景</h2><p>阅读linux0.11源码的<a href="https://github.com/labrick/linux-0.11/blob/v1.0/kernel/traps.c" target="_blank" rel="external">kernel/traps.c</a>文件里包含了几个语句是内嵌的汇编程序，虽知道整体的意思，但是细化后就不明所以然，这里记录下。</p>
<h2 id="C中嵌入汇编程序">C中嵌入汇编程序</h2><h3 id="格式">格式</h3><pre><code><span class="keyword">asm</span>(<span class="string">"汇编语句"</span>
    : 输出寄存器
    : 输入寄存器
    : 会被修改的寄存器
    );
</code></pre><p>带冒号的行可以省略，“输出寄存器”表示汇编执行完后，存放输出数据的寄存器，“输入寄存器”开始执行代码的时候，指定指定寄存器存放值。</p>
<h3 id="实例代码">实例代码</h3><h4 id="示例1">示例1</h4><pre><code><span class="keyword">int</span> a=<span class="number">10</span>,b;
asm(<span class="string">"movl <span class="variable">%1</span>, <span class="variable">%%</span>eax;
     movl <span class="variable">%%</span>eax, <span class="variable">%0</span>;"</span>
     :<span class="string">"=r"</span>(b)
     :<span class="string">"r"</span>(a)
     :<span class="string">"<span class="variable">%eax</span>"</span>
    );
</code></pre><p>表示C语言里的“b=a;”。<br>“r”表示使用任意寄存器，%0、%1表示使用两个寄存器，一般只能%0~%9共十个操作数，按输入输出寄存器出现顺序进行映射。<br>寄存器用两个百分号，是因为使用了%0%1这些数字使百分号有了特殊意义，所以在操作数出现的寄存器必须用双百分表示。<br>会被修改的寄存器里边的%eax表示eax寄存器在汇编代码块执行过程中会被改写，在执行前要保护好，这是提交给编译器决定的。</p>
<h4 id="示例2">示例2</h4><pre><code>#define get_seg_byte<span class="list">(<span class="keyword">seg</span>,addr)</span> <span class="list">({ \
    register char __res<span class="comment">; \</span>
    __asm__<span class="list">(<span class="string">"push %%fs; \                // 将fs寄存器值压栈
        mov %%ax,%%fs; \                // 将eax中的段值赋值给fs寄存器
        movb %%fs:%2,%%al; \            // 将fs:(*(addr)) --&gt; al
        pop %%fs"</span> \                        // 弹出fs
    :<span class="string">"=a"</span> <span class="list">(<span class="keyword">__res</span>)</span> \                        // 将eax值 --&gt; __res
    :<span class="string">"0"</span> <span class="list">(<span class="keyword">seg</span>)</span>,<span class="string">"m"</span> <span class="list">(<span class="keyword">*</span><span class="list">(<span class="keyword">addr</span>)</span>)</span>)</span><span class="comment">; \</span>
    __res<span class="comment">;})</span></span>
</code></pre><p>表示取段seg中地址addr处的一个字符。<br>上面是<a href="https://github.com/labrick/linux-0.11/blob/v1.0/kernel/traps.c" target="_blank" rel="external">kernel/traps.c</a>中的一段代码，其中：</p>
<p>参数：seg - 段选择符；addr - 段内指定地址。<br>输出：%0 - eax(__res)；输入：%1 - eax(seg)；%2 - 内存地址(*(addr))。<br>“=a”中的’a’称为加载代码，’=’表示这是输出寄存器，执行完后，eax的值将赋给_res,’”0” (seg)’表示在这段代码开始运行时将seg放到eax寄存器中，”0”(0可以省略)表示这里使用的寄存器和上面输出寄存器一样。</p>
<p>编译器规定：标号从输出寄存器的最左边开始，被编号为0，往右和往下将被依次编号。所以这里的”0”表示eax，”1”表示seg，”2”表示*(addr)。</p>
<p>%%fs:%2是使用编号为2的变量(*(addr))，这里加上%%fs的意思？？</p>
<h4 id="示例3">示例3</h4><p>// 取段seg中地址addr处的一个字长(4字节)。<br>// 参数：seg - 段选择符；addr - 段内指定地址。<br>// 输出：%0 - eax(__res)；输入：%1 - eax(seg)；%2 - 内存地址(*(addr))。</p>
<pre><code>#define get_seg_long<span class="list">(<span class="keyword">seg</span>,addr)</span> <span class="list">({ \
    register unsigned long __res<span class="comment">; \</span>
    __asm__<span class="list">(<span class="string">"push %%fs; \
            mov %%ax,%%fs; \
            movl %%fs:%2,%%eax; \
            pop %%fs"</span> \
    :<span class="string">"=a"</span> <span class="list">(<span class="keyword">__res</span>)</span> \
    :<span class="string">"0"</span> <span class="list">(<span class="keyword">seg</span>)</span>,<span class="string">"m"</span> <span class="list">(<span class="keyword">*</span><span class="list">(<span class="keyword">addr</span>)</span>)</span>)</span><span class="comment">; \</span>
    __res<span class="comment">;})</span></span>
</code></pre><h4 id="示例4">示例4</h4><p>// 取fs段寄存器的值(选择符)。<br>// 输出：%0 - eax(__res)</p>
<pre><code><span class="preprocessor">#define _fs() ({ \</span>
    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> __res; \
    __asm__(<span class="string">"mov %%fs,%%ax"</span> \
    :<span class="string">"=a"</span> (__res) \
    :                        <span class="comment">// 没有输入寄存器</span>
    ); \
    __res;})
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/11/git-tags-usage/" itemprop="url">
                git-tag使用
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-11T21:28:54+08:00" content="2015-09-11">
            2015-09-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/工作记录/" itemprop="url" rel="index"><span itemprop="name">工作记录</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="tag背景">tag背景</h2><p>之前很少用git tag，感觉应该挺好用的，但是懒的去学习，但最近写一些学习代码，分为几个比较明显的版本，所以就差了下怎么用，其实用起来也挺简单的，只不过需要记住条指令，这里就记录一下。</p>
<h2 id="tag使用">tag使用</h2><p>我们可以创建一个tag来指向软件开发中的一个关键时期，比如版本号更新的时候可以建一个“v2.0”、“v3.1”之类的标签，这样在以后回顾的时候会比较方便。tag的使用很简单，主要操作有：查看tag、创建tag、验证tag以及共享tag。</p>
<h3 id="查看tag">查看tag</h3><p>列出所有tag：</p>
<pre><code>git <span class="built_in">tag</span>
</code></pre><p>这样列出的tag是按字母排序的，和创建时间没关系。如果只是想查看某些tag的话，可以加限定：</p>
<pre><code><span class="label">git</span> tag -l <span class="literal">v1</span>.*
</code></pre><p>这样就只会列出1.几的版本。</p>
<h3 id="创建tag">创建tag</h3><p>创建轻量级tag：</p>
<pre><code><span class="label">git</span> tag <span class="literal">v1</span>.<span class="number">0</span>
</code></pre><p>这样创建的tag没有附带其他信息，与之相应的是带信息的tag：</p>
<pre><code>git tag -<span class="tag">a</span> v1.<span class="number">0</span>-m <span class="string">'first version'</span>
</code></pre><p>-m后面带的就是注释信息，这样在日后查看的时候会很有用，这种是普通tag，还有一种有签名的tag：</p>
<pre><code>git tag -s v1.0-m '<span class="keyword">first</span> <span class="property">version</span>'
</code></pre><p>前提是你有GPG私钥，把上面的a换成s就行了。除了可以为当前的进度添加tag，我们还可以为以前的commit添加tag：</p>
<pre><code><span class="number">1.</span> <span class="comment">#首先查看以前的commit</span>
<span class="number">2.</span> git <span class="built_in">log</span> <span class="comment">--oneline</span>
<span class="number">3.</span> <span class="comment">#假如有这样一个commit：8a5cbc2 updated readme</span>
<span class="number">4.</span> <span class="comment">#这样为他添加tag</span>
<span class="number">5.</span> git tag -<span class="operator">a</span> v1.18a5cbc2
</code></pre><h3 id="删除tag">删除tag</h3><p>很简单，知道tag名称后：</p>
<pre><code>git tag -d v1.<span class="number">0</span>
git push origin <span class="symbol">:refs/tags/v1</span>.<span class="number">0</span>
</code></pre><h3 id="验证tag">验证tag</h3><p>如果你有GPG私钥的话就可以验证tag：</p>
<pre><code><span class="label">git</span> tag -v <span class="literal">v1</span>.<span class="number">0</span>
</code></pre><h3 id="共享tag">共享tag</h3><p>我们在执行git push的时候，tag是不会上传到服务器的，比如现在的github，创建tag后git push，在github网页上是看不到tag的，为了共享这些tag，你必须这样：</p>
<pre><code>git push origin <span class="comment">--tags</span>
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/06/cmos-info/" itemprop="url">
                CMOS存储的信息
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-06T14:49:50+08:00" content="2015-09-06">
            2015-09-06
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/linux0-11相关/" itemprop="url" rel="index"><span itemprop="name">linux0.11相关</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="CMOS信息">CMOS信息</h2><p>PC机的CMOS内存是由电池供电的64或128字节内存块，通常是系统实时钟芯片RTC(Real Time Chip)的一部分。有些机器还有更大的内存容量。该64字节的CMOS原先在IBM PC-XT机器上用于保存时钟和日期信息，存放的格式是BCD码。由于这些信息仅用去14字节，因此剩余的字节就可用来存放一些系统配置数据。</p>
<p>CMOS的地址空间在基本地址空间之外，因此其中不包括可执行代码。要访问它需要通过端口0x70、0x71进行。0x70是地址端口，0x71是数据端口。为了读取指定偏移位置的字节，必须首先使用OUT指令向地址端口0x70发送指定字节的偏移位置值，然后使用IN指令从数据端口0x71读取指定的字节信息。同样，对于写操作也需要首先向地址端口0x70发送指定字节的偏移值，然后把数据写到数据端口0x71中去。</p>
<p>main.c程序第70行语句把欲读取的字节地址与0x80进行或操作是没有必要的。因为那时的CMOS内存容量还没有超过128字节，因此与0x80进行或操作是没有任何作用的。之所以会有这样的操作是因为当时Linus手头缺乏有关CMOS方面的资料，CMOS中时钟和日期的偏移地址都是他逐步实验出来的，也许在他实验中将偏移地址与0x80进行或操作(并且还修改了其他地方)后正好取得了正确的结果，因此他的代码中也就有了这步不必要的操作。不过从1.0版本之后，该操作就被去除了(可参见1.0版内核程序drives/block/hd.c 42)。下表是CMOS内存信息的一张简表：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/cmos-info/cmos-info.png" alt="CMOS 64字节信息简表"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/04/where-are-we-going-Dad/" itemprop="url">
                从爸爸去哪谈孩子的教育
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-04T10:39:19+08:00" content="2015-09-04">
            2015-09-04
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/让生活更上一层楼/" itemprop="url" rel="index"><span itemprop="name">让生活更上一层楼</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="当今形势">当今形势</h2><p>辞职之后，我所关注的领域慢慢的多了起来，加上对书籍、博客、知乎周刊的专注阅读，对所关注的领域的理解慢慢的丰盈起来。生活中的一些事情总能触发我的进一步思考，这一年来纠结、困惑、无奈与惊喜并存，偶尔会出现顿悟的感觉。</p>
<p>对于小孩子的教育问题是我在一年前看到留守儿童的问题时关注的，对这方面有着很大的无奈。</p>
<p>人生百年看似短暂，时则长远，长远到让人忘记仅仅是前一两代人的经验教训，也有可能是必须选择忘记。二十年前的中国城镇居民大多忽略对小孩子的教育问题，他们考虑更多的是经济问题，对孩子的成长过程有着很大的忽略，而这个形势又同样在今天的乡村中普遍存在，中年父母一年四季基本处于在外漂泊状态，简单供给孩子吃喝，无暇顾及孩子的心理需求，更谈不上教育，这是一个起点问题。</p>
<h2 id="爸爸去哪儿">爸爸去哪儿</h2><p>我很少看综艺节目，甚至《爸爸去哪儿》我也只是看了几期，但是看的简单的那几期（三季8期）也很让我感动，感受到爸爸与儿子女儿的相处方式，心理交流。每个孩子都有自己的特色，自己的个性，都是独特的自我。</p>
<p>诺一显然受大家的喜爱最多的一个小朋友，形象可爱，声音甜蜜，哭闹有度，相比较来说见识广博，知道自己的生活习惯应该是怎样的，可能也有人看到他的缺点：总是玩的不亦乐乎，忘记所谓的正事，但是生活有些时候也不过是开心就好。</p>
<p>诺一的可爱劲显然来自于家庭教育，评选最受欢的爸爸刘烨很轻易的当选，如果评选最受欢迎的小朋友，诺一也是必然（摔跤比赛时诺一输了，小朋友们一直让康康不要摔诺一，诺一是我们的好朋友），观看的整个过程中，我一直在关注刘烨这个人物，他这个人对小孩子有善意的欺骗（对康康说流鼻血是男子汉的象征），有实在的解释，不会拿小孩子听不懂的僵硬道理空洞的训斥孩子，都讲到的具体的点上（这一点林永健做的就不好，训斥林大俊是一遍一遍呵斥大道理，从不就事论事讲细节），也从内心当中承认自己的问题（像诺一坦白更喜欢妹妹，但不知道这个会有什么问题），但总是习惯性的用自己的方式教育别人家的孩子则是一个很大的问题，从孩子的角度来说肯定是好的，但是如果孩子他爸在场则容易让人反感。</p>
<p>夏天是一个没有公主病的小公主，和诺一类似玩的喜欢玩的不亦乐乎，更幸运的是夏天有一个同样可爱的爸爸陪她玩耍，父女两个的关系好的让人羡慕，第三季开始时两人相处的一个小时氛围实在温馨，以至于夏天都不太情愿出去，而别的小朋友则就无聊的无法忍受。</p>
<p>康康的形象也很鲜明，一个有担当、比较稳重的男子汉形象。</p>
<p>什么样的孩子更优？这个应该是没有答案的，在不同的场景、不同的时代下都不一样，但招人喜欢的孩子肯定不会太差，哭、闹都是招人喜欢的铺垫。现如今情商的可贵之处有目共睹，而诺一则可以说是情商最高的。</p>
<p>人老了就容易被感动，看着听着眼泪容易打转。</p>
<h2 id="教育">教育</h2><p>知乎周刊收录了一条答案，我觉得讲的很到位，网站找了下没找到，可能已经删了，我就摘抄到下面：</p>
<pre><code>我个人认为最好的教育，其实是营造良好的家庭氛围，在不违背重大原则的基础上，给孩子充分的自由，发挥他们自己的想象力，这样家庭出来的孩子，才最有可能超越父母的成绩。

我自己将家庭教育分为四大类：

<span class="bullet">1. </span>父母水平不高，并且以自己的标准来教育孩子：这样的孩子通常是最弱的，因为他们只能重复父母低端的老路；
<span class="bullet">2. </span>父母水平不高，但是知道自己不行，给孩子充分的爱，让孩子自己去闯：这样的孩子因为缺乏正确的借鉴，可能在成长道路上摔很多跟头，但往往可以超越父母的成绩；
<span class="bullet">3. </span>父母水平很高，并以自己的标准要求孩子：这样的孩子最好的成绩就是与父母齐平，而且有可能因为父母带来的压力而走下坡路；
<span class="bullet">4. </span>父母水平很高，但无为而治，并不直接评判孩子的好坏，而是营造宽松的环境，引导孩子学会正确的做事和思考方式：这样的孩子身边有最好的成功案例，又能充分发挥自己的聪明才智，往往能够超越父母的成绩。
</code></pre><p>我觉得这里写的很到位，但超越父母的前提是营造宽松的氛围。之前也听说一句类似的话：能力一般的过来人交给你的思想听听就行，不要认真，因为很可能就是因为这些思想导致他们成为现在的他们。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/28/linux-0-11-init/" itemprop="url">
                linux-0.11内核初始化过程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-28T14:48:09+08:00" content="2015-08-28">
            2015-08-28
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/linux0-11相关/" itemprop="url" rel="index"><span itemprop="name">linux0.11相关</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="功能描述">功能描述</h2><p>系统在执行完boot/目录中的head.s程序后就会将执行权交给main.c。该程序虽然不长，但却包括了内核初始化的所有工作。</p>
<p>main.c程序首先利用前面setup.s程序取得的系统参数<strong>设置系统的跟文件设备号</strong>以及一些内存全局变量。这些内存变量指明了主内存的开始地址、系统所拥有的内存容量和作为高速缓冲区内存的末端地址。如果还定义了虚拟盘(RAMDISK)，则主内存将适当减少。整个内存的映像示意图如下：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0-11-init/system-in-memory.png" alt="系统中内存功能划分示意图"></p>
<p>图中，高速缓冲部分还要扣除被显存和ROM BIOS占用的部分。高速缓冲区是用于磁盘等块设备临时存放数据的地方，以1K(1024)字节为一个数据块单元。主内存区域的内存由内存管理模块mm通过分页机制进行管理分配，以4K字节为一个内存页单位。内核程序可以自由访问高速缓冲中的数据，但需要通过mm才能使用分配到的内存页面。</p>
<p>然后，内核进行所有方面的硬件初始化工作。包括陷阱门、块设备、字符设备和tty，还包括人工设置第一个任务(task 0)。待所有初始化工作完成后程序就设置中断允许标志以开启中断，并切换到任务0中运行。</p>
<p>在整个内核完成初始化后，内核将执行权切换到了用户模式(任务0)，也即CPU从0特权级切换到了第3特权级。此时main.c的主程序就工作在任务0中。然后系统第一次调用进程创建函数fork()，创建出一个用于运行init()的子进程(通常被称为init进程)。系统整个初始化过程如下图：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0-11-init/init-kernel-of-main.png" alt="内核初始化程序流程示意图"></p>
<p>main.c程序首先确定如何分配使用系统物理内存，然后调用内核各部分的初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化处理。在完成了这些操作之后，该系统各部分已经处于可运行状态。此后程序把自己“手工”移动到任务0(进程0)中运行，并使用fork()调用首次创建出进程1(init进程)，并在其中调用init()函数。在该函数中程序将继续进行应用环境的初始化并执行shell登录程序。而原进程0则会在系统空闲时被调度执行，因此进程0通常也被称为idle进程。此时进程0仅执行pause()系统调用，并又会调用调度函数。</p>
<p>init()函数的功能可分为4个部分：</p>
<ol>
<li>安装根文件系统；</li>
<li>显示系统信息；</li>
<li>运行系统初始资源配置文件rc中的命令；</li>
<li>执行用户登录shell程序。</li>
</ol>
<p>代码首先调用系统调用setup()，用来收集硬盘设备分区表信息并安装根文件系统。在安装根文件系统之前，系统会先判断是否需要先建立虚拟盘。若编译内核时设置了虚拟盘的大小，并在前面内核初始化过程中已经开辟了一块内存用作虚拟盘，则内核就会首先尝试把根文件系统加载到内存的虚拟盘区中。</p>
<p>然后init()打开了一个中断设备tty0，并复制器文件描述符以产生标准输入stdin、标准输出stdout和错误输出stderr设备。内存随后利用这些描述符在终端上显示一些系统信息，例如高速缓冲区中缓冲块总数、主内存区空闲内存总字节数等。</p>
<p>接着init()又新建了一个进程(进程2)，并在其中为建立用于交互使用环境而执行一些初始配置操作，即在用户可以使用shell命令行环境之前，内核调用/bin/sh程序运行了配置文件etc/rc中设置的命令。rc文件的作用与DOS系统根目录上的AUTOEXEC.BAT文件类似。这段代码首先通过关闭文件描述符0，并立刻打开文件/etc/rc，从而把标准输入stdin定向到etc/rc文件上。这样，所有的标准输入数据都将从该文件中读取。然后内核以非交互形式执行/bin/sh，从而实现执行/etc/rc文件中的命令。当该文件中的命令执行完毕后，/bin/sh就会立刻退出。因此进程2也就随之结束。</p>
<p>init()函数的最后一部分用于在新建进程中为用户建立一个新的会话，并运行用户登录shell程序/bin/sh。在系统执行进程2中的程序时，父进程(init进程)一直等待着它的结束。随着进程2的退出，父进程就进入了一个无限循环中。在该循环中，父进程会再次生成一个新进程，然后在该进程中创建一个新的会话，并以登录shell方式再次执行程序/bin/sh，以创建用户交互shell环境。然后父进程继续等待该子进程。登录shell虽然与前面的非交互式shell是同一个程序/bin/sh，但是所使用的命令行参数(argv[])不同。登录shell的第0个命令行参数的第1个字符一定是一个减少’-‘。这个特定的标志会在/bin/sh执行时通知它这不是一次普通的运行，而是作为登录shell运行/bin/sh的。从这时开始，用户就可以正常使用Linux命令行环境了，而父进程随之又进入等待状态。此后若用户在命令上执行了exit或logout命令，那么在显示一条当前登录shell退出的信息后，系统就会在这个无限循环中再次重复以上创建登录shell进程的过程。</p>
<p>任务1中运行的init()函数的后两部分实际上应该是独立的环境初始化程序init等的功能。</p>
<h2 id="注意">注意</h2><p>由于创建新进程的过程是通过完全复制父进程代码段和数据段的方式实现，因此在首次使用fork()创建新进程init时，为了确保新进程用户态栈中没有进程0的多余信息，要求进程0在创建首个新进程(进程1)之前不要使用其用户态栈，<strong>即要求任务0不要调用函数</strong>。因此在main.c主程序移动到任务0执行后，任务0中的代码fork()不能以函数形式进行调用。程序中实现的方法是采用如下所示的gcc函数内嵌(内联)形式来执行这个系统调度：</p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>,fork)
</code></pre><p>其中_syscall0()是unistd.h种的内嵌宏代码，它以嵌入汇编的形式调用Linux的系统调用中断int 0x80。根据include/unistd.h文件第133行上的宏定义，我们把这个宏展开并替代进上面一行中就可以看到这条语句实际上是int fork()创建进程系统调用，见如下：</p>
<pre><code><span class="comment">//unistd.h文件中_syscall0()的定义。即为不带参数的系统调用宏函数:type name(void)</span>
#define _syscall0(<span class="class"><span class="keyword">type</span>,<span class="title">name</span>) \</span>
<span class="class"><span class="keyword">type</span> <span class="title">name</span></span>(<span class="keyword">void</span>) \
{ \
long __res; \
__asm__ volatile (<span class="string">"int $0x80"</span> \        <span class="comment">// 调用系统中断0x80</span>
    : <span class="string">"=a"</span> (__res) \                <span class="comment">// 返回值--&gt;eax(__res)</span>
    : <span class="string">"0"</span> (__NR_##name)); \            <span class="comment">// 输入为系统中断调用号__NR_name</span>
<span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \
    <span class="keyword">return</span> (<span class="class"><span class="keyword">type</span>) <span class="title">__res</span>; \</span>
errno = -__res; \                    <span class="comment">// 否则置出错号，并返回-1</span>
<span class="keyword">return</span> -<span class="number">1</span>; \
}
</code></pre><p>根据上面定义把_syscall0(int,fork)展开代进第23行后我们可以得到如下语句：</p>
<pre><code><span class="keyword">static</span> inline <span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="keyword">long</span> __res;
    __asm__ <span class="keyword">volatile</span> (<span class="string">"int $0x80"</span> : <span class="string">"=a"</span> (__res) : <span class="string">"0"</span> (__NR_fork));
    <span class="keyword">if</span> (__res &gt;= <span class="number">0</span>)
        <span class="keyword">return</span> (<span class="keyword">int</span>) __res;
    errno = -__res;
    <span class="keyword">return</span> -<span class="number">1</span>;
}
</code></pre><p>gcc会把上述“函数”体中的语句直接插入到调用fork()语句的代码处，因此执行fork()不会引起函数调用。另外，宏名称字符串“syscall0”中最后的0表示无参数，1表示带1个参数。如果系统调用带有1个参数，那么久应该使用宏_syscall1()。</p>
<p>虽然上面系统中断调用执行中断指令INT时还是避免不了使用堆栈，但是系统调用使用任务的内核态栈而非用户栈，并且每个任务都有自己独立的内核态栈，因此系统调用不会影响这里讨论的用户态栈。</p>
<p>另外，在创建新进程init(即进程1)的过程中，系统对其进行了一些特殊处理。进程0和进程init实际上同时使用着内核代码区内(小于1MB的物理内存)相同的代码和数据物理内存页面(640KB)，只是执行的代码不再一处，因此实际上它们也同时使用着相同的用户堆栈区。在为新进程init复制器父进程(进程0)的页目录和页表项时，进程0的640KB页表项属性没有改动过(仍然可读写)，但是进程1的640KB对应的页表项却被设置成了只读。因此当进程1开始执行时，其对用户栈的出入栈操作将导致页面写保护异常，从而会使得内核的内存管理为进程1在主内存区中分配一内存页面，并把任务0栈中相应页面内容复制到此新页面上。从此时起，任务1的用户态栈开始有自己独立的内存页面。即从任务1执行过出/入栈操作后，任务0和任务1的用户栈才变成相互独立的栈。为了不出现冲突问题，就必须要求任务0在任务1执行栈操作之前禁止使用到用户堆栈区域，而让进程init能单独使用堆栈。因为在内核调度进程运行时次序是随机的，有可能在任务0创建了任务1后仍然先允许任务0。因此任务0执行fork()操作后，随后的pause()函数也必须采用内嵌函数形式来实现，以避免任务0在任务1之前使用用户栈。</p>
<p>当系统中一个进程(例如init进程的子进程，进程2)执行过execve()调用后，进程2的代码和数据区会位于系统的主内存区中，因此系统此后可以随时利用写时复制技术(Cpoy on Write)来处理其他新进程的创建和执行。</p>
<p>对于Linux来说，所有任务都是在用户模式下运行的，包括很多系统应用程序，如shell程序、网络子系统程序等。内核源代码lib/目录的库文件(除其中的string.c程序)就是专门为这里新创建的进程提供函数支持，内核代码本身并不使用这些库函数。</p>
<h2 id="注释">注释</h2><ol>
<li>内联(inline)函数：通过声明一个内联函数，可以让gcc把函数的代码集成到调用它的代码中。这会提高代码执行的速度，因为省去了函数调用的开销。另外，如果任何一个实际参数是一个常量，那么在编译时这些已知值就可能使用无需把内嵌函数的所有代码都包括进来而让代码也得到简化。</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/26/8259A-interrupt-control/" itemprop="url">
                8259A中断控制器编程方法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-26T10:25:04+08:00" content="2015-08-26">
            2015-08-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/linux0-11相关/" itemprop="url" rel="index"><span itemprop="name">linux0.11相关</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="8259A芯片工作原理">8259A芯片工作原理</h2><p>PC/AT系列兼容机中使用了级联的两片8259A可编程控制器(PIC)芯片，可共管理15级中断向量，其中从芯片的INT引脚连接到主芯片的IR2引脚上。主8259A芯片的端口基地址是0x20，从芯片是0xA0。一个8259A芯片的逻辑框图如下：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/8259A-interrupt-control/8259A-interrupt-control.png" alt="可编程中断控制器8259A芯片框图"></p>
<p>中断请求寄存器IRR(Interrupt Request Register)用来保存中断请求输入引脚上所有请求服务中断级，寄存器的8个比特位(D7—D0)分别对应引脚IR7—IR0。</p>
<p>中断屏蔽寄存器IMR(Interrupt Mask Register)用于保存被屏蔽的中断请求线对应的比特位，寄存器的8位也是对应8个中断级。哪个比特位被置1就屏蔽哪一级中断请求。即IMR对IRR进行处理，其每个比特位对应IRR的每个请求比特位。对高优先级输入线的屏蔽并不会影响低优先级中断请求线的输入。</p>
<p>优先级解析器PR(Priority Resolver)用于确定IRR中所设置比特位的优先级，选通最高优先级的中断请求到正在服务寄存器ISR(In-Service Register)中。ISR中保存着正在接受服务的中断请求。</p>
<p>控制逻辑方框中的寄存器组用于接收CPU产生的两类命令。在8259A可以正常操作之前，必须首先设置初始化命令字ICW(Initialization Command Words)寄存器组的内容。而在其工作过程中，则可以使用写入操作命令字OCW(Operation Command Words)寄存器组来随时设置和管理8259A的工作方式。A0线用于选择操作的寄存器。在PC/AT微机系统中，当A0线为0时芯片的端口地址是0x20和0xA0(从芯片)，当A0=1时端口就是0x21和0xA1。</p>
<p>来自各个设备的中断请求线分别连接到8259A的IR0—IR7中断请求引脚上。当这些引脚上有一个或多个终端请求信号时，中断请求寄存器IRR中相应的比特位被置位所存。此时若中断屏蔽寄存器IMR中对应位被置位，则相应的中断请求就不会被送到优先级解析器中。对于未屏蔽的中断请求被送到优先级解析器之后，优先级最高的中断请求会被选中。此时8259A就会向CPU发出一个INT信号，而CPU则会在执行完当前的一条指令之后向8259A发送一个INTA来相应中断信号。8259A在收到这个相应信号之后就会把所选出的最高优先级中断请求保存到正在服务寄存器ISR中，即ISR中对应中断请求级的比特位被置位。与此同时，中断请求寄存器IRR中的对应比特位被复位，表示该中断请求开始正被处理中。</p>
<p>此后，CPU会向8259A发送第2个INTA脉冲信号，该信号用于通知8259A送出中断号。因此在该脉冲信号期间8259A就会把一个代表中断号的8位数据发送到数据总线上共CPU读取。</p>
<p>到此为止，CPU中断周期结束。如果8259A使用的是自动结束中断AEOI(Automatic End of Interrupt)方式，那么在第2个INTA脉冲信号的结尾处正在服务寄存器ISR中的当前服务中断比特位就会被复位。否则的话，若8259A处于非自动结束方式，那么在中断服务程序结束时程序就需要项8259A发送一个结束中断(EOI)命令以复位ISR中的比特位。如果中断请求来自级联的第2个8259A芯片，那么就需要项两个芯片都发送EOI命令。此后8259A就会去判断下一个最高优先级的中断，并重复上述处理过程。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/13/linux-0-11-boot/" itemprop="url">
                linux-0.11启动过程描述
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-13T21:20:27+08:00" content="2015-08-13">
            2015-08-13
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/linux0-11相关/" itemprop="url" rel="index"><span itemprop="name">linux0.11相关</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="简单描述">简单描述</h2><p>当PC的电源打开后，80X86结构的CPU将自动进入实模式，并从地址0xFFFF0开始自动执行程序代码，这个地址通常是ROM-BIOS中的地址。PC机的BIOS将执行某些系统的检测，并在物理地址0处开始初始化中断向量。此后，它将可启动设备的第一个扇区（磁盘引导扇区，512字节）读入内存绝对地址0x7C00处，并跳转到这个地方。启动设备通常是软驱或是硬盘。</p>
<h2 id="启动之前">启动之前</h2><p>Linux启动是需要启动盘的，这里假定启动盘就是当时的1.44MB的A盘。我们先来看下各个模块在启动盘的位置信息。</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/disk-of-start-linux-0.11.png" alt="Linux 0.11内核在1.44MB磁盘上的分布情况"></p>
<p>1.44MB磁盘共有2880个扇区（1.44*1000*1000/500=2880，要理解奸商的计算方式），bootsect.s代码是磁盘引导块程序，驻留在磁盘的第一个扇区中（引导扇区，0磁道（柱面），0磁头，第1个扇区），setup模块占用随后的4个扇区，而0.11内核system模块大约占随后的240个扇区。还剩下2630个扇区未被使用。这些剩余的未用空间可被利用来存放一个基本的根文件系统，从而可以创建处使用单张磁盘就能让系统运转起来的集成盘来。</p>
<h2 id="启动过程">启动过程</h2><p><a href="https://github.com/labrick/linux-0.11/tree/v1.0/boot" target="_blank" rel="external">这里</a>我们可以看到linux/boot/目录下有三个文件和启动相关。</p>
<h3 id="BIOS和boot/bootsect-s">BIOS和boot/bootsect.s</h3><p>Linux最开始的部分是用8086汇编语言编写的(boot/bootsect.s)，它将由ROM BIOS自检后读入到内存绝对地址0x7C00(31KB)处并执行之，bootsect执行时，就会把自己[1]移动到内存绝对地址0x90000(576KB)处，并把启动设备中后2KB字节代码(boot/setup.s)读入到内存0x90200处，然后利用BIOS终端0x13取磁盘参数表中当前启动引导盘的参数，接着在屏幕上显示“Load<br>system…”字符串。而后将system模块读入到内存地址0x10000(64KB)开始处，因为当时system模块的长度不会超过0x80000字节大小（即512KB），所以bootsect程序把system模块读入物理地址0x10000开始位置处时并不会覆盖在0x90000(576KB)处开始的bootsect和setup模块。随后确定根文件系统的设备号，若没有指定，则根据所保存的引导盘的每磁道扇区数判别出盘的类型和种类（是1.44MB A盘吗？）并保存其设备号于root_dev（引导块的508地址处），最后长跳转到setup程序的开始处(0x90200)执行setup程序。</p>
<p>从机器加电开始顺序执行的程序如下图：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/process-of-linux-starting.png" alt="从系统加点起所执行程序的顺序"></p>
<h3 id="boot/setup-s">boot/setup.s</h3><p>boot/setup.s主要负责利用ROB BIOS终端读取机器系统数据，并将这些数据保存到0x90000开始的位置（覆盖掉了bootsect程序所在的位置），所去读取的参数和保留的内存位置如下表：（这些参数将被内核中的相关程序使用）</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/param-of-setup-reading.png" alt="setup程序读取并保存的参数"></p>
<p>然后setup程序将system模块移动到物理内存起始位置处[2]，这样system模块中代码的地址也即等于实际的物理地址，便于对内核代码和数据进行操作。下图清晰地显示出Linux系统启动时这几个程序或模块在内存中的动态位置。其中，每一竖条框代表某一时刻内存中个程序的映像位置图。在系统加载期间将显示信息“Loading…”。然后控制权将传递给boot/setup.s中的代码，这是另一个实模式汇编语言程序。</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/placement-and-movement-of-linux-kernel-in-mm-when-start.png" alt="启动引导时内核在内存中的位置和移动后的情况"></p>
<p>接下来加载中断描述符表寄存器(idtr)和全局描述符表寄存器(gdtr)，开启A20地址线，重新设置两个终端控制芯片8259A，将硬件中断号重新设置为0x20-0x2f。最后设置CPU的控制寄存器CR0(也称机器状态字),从而进入32位保护模式运行，并跳转到位于system模块最前端部分的head.s程序继续运行。</p>
<p>为了能够head.s在32位保护模式下运行，在本程序中临时设置了中断描述符表(IDT)和全局描述符表(GDT)，并在GDT中设置了当前内核代码段的描述符和数据段的描述符。下面在head.s程序中会根据内核的需要重新设置这些描述符表。</p>
<h3 id="boot/head-s">boot/head.s</h3><p>head.s程序在被编译生成目标文件后会与内核其他程序一起被链接成system模块，位于system模块的最前面开始部分，这也就是为什么称其为头部(head)程序的原因。system模块将被放置在磁盘上setup模块之后开始的扇区中，即从磁盘上第6个扇区开始放置。一般情况下Linux0.11内核的system模块大约有120KB左右，因此在磁盘上大约占240个扇区。</p>
<p>从这里开始，内核完全都是在保护模式下运行了。head.s汇编程序与前面的语法格式不同，它采用的是AT&amp;T的汇编语言格式，并且需要使用GNU的gas和gld进行编译链接。因此要注意代码中赋值的方向是从左到右。</p>
<p>这段程序实际上处于内存绝对地址0处开始的地方。这个程序的功能比较单一。首先是加载各个数据段寄存器，重新设置中断描述符表idt，共256项，并使各个表项均指向一个只报错误的哑中断子程序ignore_int。中断描述符表中每个描述符项也占8字节，其格式如下：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/idt-interrupt-diagram.png" alt="中断描述符表IDT中的中断门描述符格式"></p>
<p>在设置好中断描述符表之后，本程序又重新设置了全局段描述符表gdt。实际上新设置的GDT表与原来在setup.s程序中设置的GDT表描述符除了在段限长上有些区别以外(原为8MB，现为16MB)，其他内容完全一样。当然我们也可以在setup.s程序中就把描述符的段限长直接设置成16MB，然后直接把原GDT表移动到内存适当位置处。因此这里重新设置GDT的主要原因是为了把gdt表放在内存内核代码比较合理的地方。前面设置的GDT表处于内存0x902XX处。这个地方将在内核初始化后用作内存高速缓冲区的一部分。</p>
<p>接着使用物理地址0与1MB开始处的字节内容相比较的方法，检测A20地址线是否已真的开启。如果没有开启，则在访问高于1MB物理内存地址时CPU实际只会循环访问(IP MOD 1Mb)地址处的内容，也即与访问从0地址开始对应字节的内容都相同。如果检测下来发现没有开启，则进入死循环。然后程序测试PC机是否含有数学协处理芯片(80287、80387或兼容芯片)，并在控制寄存器CR0中设置相应的标志位。</p>
<p>接着设置管理内存的分页处理机制，将页目录表放在绝对物理地址0开始处(也是本程序所处的物理内存位置，因此这段程序将被覆盖掉)，紧随后面放置共可寻址16MB的4个页表，并分别设置它们的表项。页目录表项和页表项格式如下。</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/page-iterm-and-structure.png" alt="页目录表项和页表项结构"></p>
<p>这里每个表项的属性标志都被设置成0x07(P=1、U/S=1、R/W=1)，表示该页存在、用户可读写。这样设置内核页表属性的原因是:CPU的分页机制和分页管理都有保护方法。分页机制中页目录表和页表项中设置的保护标志(U/S、R/W)需要与段描述符中的特权级(PL)保护机制一起组合使用。但段描述符中的PL其主要作用。CPU会首先检查段保护，然后再检查页保护。如果当前特权级CPL&lt;3(例如0)，则说明CPU正在以超级用户(Supervisor)身份运行。此时所有页面都能访问，并可随意进行内存读写操作。入宫CPL=3，则说明CPU正在以用户(User)身份运行。此时只有属于User的页面(U/S=1)可以访问，并且只有标记为可读写的页面(W/R=1)是可写的。而此时属于超级用户的页面(U/S=0)则既不可写、也不可以读。由于内核代码有些特别之处，即其中包含有任务0和任务1的代码和数据。因此这里把页面属性为0x7就可保护这两种任务代码不仅可以在用户态下执行，而且又不能随意访问内核资源。</p>
<p>最后，head.s程序利用返回指令将预先放置在对战中的/init/main.c程序的入口地址弹出，去运行main()程序。</p>
<p>head.s程序执行结束后，已经正式完成内存页目录和页表的设置，并重新设置了内核实际使用的中断描述符表idt和全局描述符表gdt。另外还为软盘驱动程序开辟了1KB字节的缓冲区。此时system模块在内存中的详细映像如下：</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/linux-0.11-start/system-in-memory.png" alt="system模块在内存中的映像示意图"></p>
<p>启动部分识别主机的某些特性以及VGA卡的类型。如果需要，它会要求用户为控制台选择模式。然后将整个系统从地址0x10000移至0x0000处[3]，进入保护模式并跳转至系统的余下部分（在0x0000处）。此时所有32位运行方式的设置启动被完成：IDT、GDT以及LDT被加载，处理器和协处理器也已确认，分页工作也设置好了；最终调用init/main.c中的main()程序。</p>
<p>boot/head.s可能是整个内核中最有诀窍的代码。</p>
<h3 id="注意点">注意点</h3><p>上面的所有过程都不能出错，一旦出错，计算机就会死机，在操作系统还没有完全运转之前是处理不了出错的。</p>
<h2 id="根文件系统问题[4]">根文件系统问题[4]</h2><p>仅在内存中加载上述内核代码模块并不能让Linux系统运行起来。作为完整可运行的Linux系统还需要有一个基本的文件系统支持，即根文件系统。Linux<br>0.11内核仅支持MINIX的1.0文件系统。根文件系统通常在另一个软盘上或者在一个硬盘分区中。为了通知内核所需要的根文件系统在什么地方，bootsect.s程序的第43行上给出了根文件系统所在的默认块设备号。在内核初始化时会使用编译内核时放在引导扇区第509、510(0x1fc—0x1fd)字节中的指定设备号。</p>
<h2 id="疑问点">疑问点</h2><ol>
<li><p>是谁将bootsect移动到内存绝对地址0x90000(576KB)处，是bootsect自身？</p>
<p> 答：按照上述理解与分析，搬移bootsect程序的应该是它自身。</p>
</li>
<li><p>系统上电时BOIS已经在起始位置（也就是物理地址0位置）初始化了中断向量，此处将system模块还移动到物理内存其实位置处不会覆盖之前的中断向量？</p>
<p> 答：这是因为BIOS ROM中的中断调用（大小为0x400直接，也就是1KB）是用来获取机器的一些参数（例如显示模式、硬盘参数表等）。而启动setup程序时，这些参数已经获取完毕，就可以直接被覆盖掉了，这也是bootsect不把system模块直接加载到物理地址0x0000开始处的原因。(真的是这样吗？系统启动之后就不再需要这些中断了？可是微机实验中的中断都是可用的啊？)</p>
</li>
<li><p>上面已经说是setup完成的将system模块（也就是整个系统）移动到物理内存起始位置，但是此处由说是head进行的搬移，似乎出现了矛盾？</p>
</li>
<li><p>为什么需要有文件系统才能使Linux系统运行起来，内核模块应该运行起来了吧？</p>
</li>
</ol>
<h2 id="从硬盘启动系统">从硬盘启动系统</h2><p>若需要从硬盘设备启动系统，那么通常需要使用其他多操作系统引导程序来引导系统加载。比如：Shoelace、LILO或Grub等多操作系统引导程序。此时bootsect.s所完成的任务会由这些程序来完成。bootsect程序就<strong>不会被执行</strong>了。因为如果从硬盘启动系统，那么通常内核映像文件<strong>Image会存放在活动分区的根文件系统中</strong>。因此你就需要知道内核映像文件Image处于文件系统中的位置以及是什么文件系统。即你的引导扇区程序需要能够识别并访问文件系统，并从中读取内核映像文件。</p>
<p>从硬盘启动的基本流程是：系统上电后，可启动硬盘的第1个分区（主引导记录MBR - Master Boot Record）会被BIOS加载到内存0x7c00处并开始执行。改程序会首先把自己向下移动到内存0x600处，然后根据MBR中分区表信息所指明活动分区中的第1个扇区（引导扇区）加载到内存0x7c00处，然后开始执行之。如果直接使用这种方法来引导系统就会碰到这样一个问题：即根文件系统不能与内核映像文件Image共存。</p>
<p>我所想到的解决方法有两个。一种办法是专门设置一个小容量的活动分区来存放内核映像文件Image。而相应的根文件系统则放在另一个分区中。这样虽然浪费了硬盘的4个主分区之一，但应该能在对bootsect.s程序作最少修改的前提下做到从硬盘启动系统。另一个办法是把内核映像文件Image与根文件系统组合存放在一个分区中，即内核映像文件Image放在分区开始的一些扇区中，而根文件系统则从随后某一指定扇区开始存放。这两种方法均需要对代码进行一些修改。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/11/translate-abc-xyz/" itemprop="url">
                Google集团Alphabet
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-11T06:54:49+08:00" content="2015-08-11">
            2015-08-11
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/突发奇想的小玩意/" itemprop="url" rel="index"><span itemprop="name">突发奇想的小玩意</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="文章背景">文章背景</h2><p>今天Google成立了新的母公司Alphabet，话说是因为Google代表搜索引擎，但是公司内部做了很多和核心业务没有关联的项目工程，或者实验，为了更好的组织公司，可能还有其他方面的原因成立了Aphabet，<a href="https://abc.xyz/" target="_blank" rel="external">文章网址在此</a>，和我的域名很像~-~，当时头脑一发热注册abc就发财了~-~</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/translate-abc-xyz/abc-xyz.jpg" alt="abc-xyz"></p>
<h2 id="G就代表Google">G就代表Google</h2><p>11年前Google刚创建的时候，Sergey和我一同写了一个声明：“Google不是一个传统型公司，我们的目的也不是创建一个传统型公司。”作为那时的补充，我们再次声明：你可能希望我们在一些非常有前景或者比较奇怪的领域，以比我们现在的业务更小的赌注来做事。作为开始，我们总是在努力的路上，用我们所拥有的资源来做重要而有意义的事。</p>
<p>我们已经做了很多看起来很疯狂的产品，这些产品中已经有很多拥有十亿以上的用户，比如：Google Maps, YouTube, Chrome, 还有Android. 但是我们不会满足于现在。我们仍然要尝试去做人们认为很疯狂，但是能让我们超级兴奋的事情。</p>
<p>我们一直相信，过去的公司通常做相同的事情来让公司平稳的发展，最多做一些增长性的改变。但是对于科技领域，变革思想才能驱动下一个大的增长，这样你就需要待在相关的不舒服的位置。</p>
<p>如今，我们公司管理的不错，但是我们想我们可以让她变得更整洁，更加的权责分明。因此我们创建了一个公司叫：Alphabet。我很荣幸的作为Alphabet公司的CEO来帮助我们有才能的董事会主席Sergey。</p>
<h2 id="什么是Alphabet？">什么是Alphabet？</h2><p>Alphabet更像是一个公司的集合（集团），公司中的老大当然是Google。</p>
<pre><code>This newer Google <span class="keyword">is</span> a bit slimmed down, <span class="keyword">with</span> <span class="keyword">the</span> companies <span class="keyword">that</span> are pretty far afield <span class="keyword">of</span> our main internet products contained <span class="keyword">in</span> Alphabet instead. What do we mean <span class="keyword">by</span> far afield? Good examples are our health efforts: Life Sciences (<span class="keyword">that</span> works <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> glucose-sensing contact lens), <span class="keyword">and</span> Calico (focused <span class="function_start"><span class="keyword">on</span></span> longevity).
</code></pre><p>我们认为这样从根本上让我们有一个更合适的管理规模，可以让各个部分没有相互影响的独立运行。</p>
<h2 id="成立Alphabet的初衷">成立Alphabet的初衷</h2><p>Alphabet通过独立的运作，并配备有能力的领导人而使业务更加繁荣的方法。通常情况下，我们让一位有能力的CEO独立的运作一个业务，然后在需要的时候，Sergey和我来为他们服务。我们严格的控制资本和业务的分配来确保每一个业务都能很好的运作。我们也会确保每一个业务都有一个很好的CEO，并且决定他们的薪资。另外，在这个新的组织结构内：</p>
<pre><code>we plan <span class="built_in">to</span> implement <span class="keyword">segment</span> reporting <span class="keyword">for</span> our Q4 results, where Google financials will be provided separately than those <span class="keyword">for</span> <span class="operator">the</span> rest <span class="operator">of</span> Alphabet businesses <span class="keyword">as</span> <span class="operator">a</span> <span class="keyword">whole</span>.
</code></pre><p>这种新的组织结构将让我们更关注与Google视角的非凡机会，这里的关键是Sundar Pichai。从今以后，Sundar做我之前做的事（有时他做的更好！），我们一起很快的工作。从去年10月分至今，在负责我们互联网业务的产品和工程上，他已经上岗上道了。Sergey和我对他所开展的工作和所做的贡献也都非常满意。是时候让Sundar担任Google的CEO，这一点对我们及董事会都是很显然的。公司能拥有像他那样有才能的人，给Google瘦身，这些给我节省了时间以方便我规划我们的前景。我也已经花了一些时间来和Sundar一起做事，在我能帮助的地方帮助他和公司，当然，我还会急需做这件事。Google自己也在对新的产品进行规划，并且我知道Sundar将继续注重于创新—继续拓展新的边界。我还知道他一直关心在我们的核心任务（组织全世界的信息）上做出大的跨步。最近发起的基于机器学习的Google Photos和Google Now取得了惊人的进步。Google也有一些独立运行的服务，比如YouTube，Suasan作为他的CEO正在运作一个强大的品牌并取的难以置信的业绩增长。</p>
<p>Sergey和我对开启新的东西很感兴趣，Alphabet将包含我们的X实验室（which incubates new efforts like Wing, our drone delivery effort.）。作为这种新结构的一部分，我们又增加了我们的投资机构，合资企业和资本。</p>
<p>Alphabet公司将会在公众贸易实体上取代Google公司，并且Google所有的股份将会自动转化为相同份额的Alphabet股份，权利也完全相同。Google将变成一个完全独立的Alphabet的子公司。我们的两级股份将继续在纳斯达克以GOOGL和GOOG交易。</p>
<p><img src="http://7xkoxp.com1.z0.glb.clouddn.com/translate-abc-xyz/alphabet.png" alt="Alphabet"></p>
<h2 id="Alphabet名字的由来">Alphabet名字的由来</h2><p>对于Sergey和我来说，这是Google一生中非常令人兴奋的新篇章—Alphabet的诞生。我们很喜欢Alphabet这个名字，因为它意味可以代表语言的所有字母的合计，而且语言是人类最重要的发明之一，也是怎样索引Google搜索的关键。我们也很喜欢它alpha-bet（Alpha是在benchmark上的投资回报）的含义，促使我们大踏步的前进。我还应该加一句：我们的目的并不是以此作为一个与产品相关的消费品牌—所有的重点在于Alphabet公司有自己独立发展的品牌。</p>
<h2 id="未来的事">未来的事</h2><p>我们对下面的事情感到兴奋：</p>
<ul>
<li>做一些更有雄心的事情</li>
<li>从长远的视角来看待问题</li>
<li>使我们伟大的企业繁荣昌盛</li>
<li>投资我们能看到的机会和资源</li>
<li>提高我们所做事情的透明度和监督程度</li>
<li>通过聚焦于伟大来使Google更好</li>
<li>希望以此来提高尽可能多人们的生活水平</li>
</ul>
<p>什么可以做的更好？不用怀疑，我们在Alphabet家庭里共同愉快的合作。不用担心，我们仍然遵循我们名字的格言。</p>
<p>Larry Page</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>


            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="pumpkin" itemprop="image"/>
          <p class="site-author-name" itemprop="name">pumpkin</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pumpkin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  

  



  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  
  

  







<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
